<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Driver Chart</title>
    <link href="/assets/css/terminal.css" rel="stylesheet">
    <link href="/assets/css/driverChart.css" rel="stylesheet">

</head>

<body>
    <div class="wrapper-v j-center nopadding bordered-grid driver-chart shadowed-dark">
        <div class="wrapper-h h-fit-content j-sb nopadding">
            <div class="wrapper-h h-fit-content j-start">
                <h1 class="">
                    Timeline Autista
                </h1>
            </div>
        </div>
        <div class="wrapper-h j-center a-center nopadding bordered-top">
            <div class="wrapper-v j-start nopadding w-fit-content bordered-right">
                <div class="wrapper-v j-start w-fit-content y-axis">
                    <div class="y-axis-label wrapper-v j-center a-center bordered-bottom">
                        <p>Guida</p>
                    </div>
                    <div class="y-axis-label wrapper-v j-center a-center bordered-bottom">
                        <p>Lavoro</p>
                    </div>
                    <div class="y-axis-label wrapper-v j-center a-center bordered-bottom">
                        <p> Riposo</p>
                    </div>
                </div>
                
            </div>
            <div class="wrapper-v j-sb a-center nopadding">
                <div class="wrapper-v j-start a-start" style="overflow-x:auto; overflow-y:hidden; position:relative" id="bar-container">
                    <div class="wrapper-v j-center a-start nopadding w-fit-content">
                        <div class="activity-bar"></div>
                    </div>  
                    <div class="wrapper-v j-center a-start nopadding">
                        <div class="work-bar"></div>
                    </div>
                    <div class="wrapper-v j-center a-start nopadding">
                        <div class="rest-bar"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
        (() => {
            const HOUR_MS = 60 * 60 * 1000;
            const DAILY_LIMIT_MS = 9 * HOUR_MS;
            const DAILY_EXT_LIMIT_MS = 10 * HOUR_MS; // max lawful driving/working per day
            const DEFAULT_PX_PER_HOUR = 50;
            let pxPerHour = DEFAULT_PX_PER_HOUR;
            let timelineStartMs = null;
            let timelineEndMs = null;
            let cachedEvents = [];
            let cachedSegments = [];
            let cachedStartMs = null;
            let cachedEndMs = null;
            const driverId = "I100000569493003";
            const imei = "864275071761426";
            const barContainer = document.getElementById("bar-container");
            if (barContainer) {
                barContainer.style.cursor = "crosshair";
            }
            const applyPxPerHour = () => {
                document.documentElement.style.setProperty("--px-per-hour", `${pxPerHour}px`);
            };
            applyPxPerHour();
            const bars = {
                driving: document.querySelector(".activity-bar"),
                working: document.querySelector(".work-bar"),
                resting: document.querySelector(".rest-bar")
            };
            const palette = {
                driving: "var(--tv-green)",
                working: "var(--tv-warning)",
                resting: "var(--tv-blue)",
                overtime: "var(--tv-red)"
            };
            const labels = {
                driving: "Guida",
                working: "Lavoro",
                resting: "Riposo"
            };
            const formatClockTime = (ms) => {
                if (!Number.isFinite(ms)) return "--:--";
                const d = new Date(ms);
                return `${String(d.getHours()).padStart(2, "0")}:${String(d.getMinutes()).padStart(2, "0")}`;
            };
            const crosshair = (() => {
                const v = document.createElement("div");
                const h = document.createElement("div");
                v.style.position = h.style.position = "absolute";
                v.style.pointerEvents = h.style.pointerEvents = "none";
                v.style.background = h.style.background = "rgba(255,255,255,0.35)";
                v.style.width = "1px";
                h.style.height = "1px";
                v.style.top = "0";
                h.style.left = "0";
                v.style.opacity = h.style.opacity = "0";
                v.style.zIndex = h.style.zIndex = "9998";
                h.style.zIndex = "9997";
                barContainer?.style.setProperty("position", "relative");
                if (barContainer) {
                    barContainer.appendChild(v);
                    barContainer.appendChild(h);
                }
                const show = (x, y) => {
                    if (!barContainer) return;
                    v.style.left = `${x}px`;
                    v.style.height = `${barContainer.scrollHeight}px`;
                    h.style.top = `${y}px`;
                    h.style.width = `${barContainer.scrollWidth}px`;
                    v.style.opacity = h.style.opacity = "1";
                };
                const hide = () => {
                    v.style.opacity = h.style.opacity = "0";
                };
                return { show, hide };
            })();
            const tooltip = (() => {
                const el = document.createElement("div");
                el.style.position = "fixed";
                el.style.zIndex = "9999";
                el.style.padding = "6px 10px";
                el.style.background = "rgba(0,0,0,0.85)";
                el.style.color = "#fff";
                el.style.borderRadius = "6px";
                el.style.fontSize = "12px";
                el.style.pointerEvents = "none";
                el.style.opacity = "0";
                el.style.transition = "opacity 120ms ease";
                document.body.appendChild(el);
                const show = (text, x, y) => {
                    el.textContent = text;
                    el.style.left = `${x + 8}px`;
                    el.style.top = `${y - 10}px`;
                    el.style.opacity = "1";
                };
                const hide = () => {
                    el.style.opacity = "0";
                };
                return { show, hide };
            })();

            const stateFromRecord = (record) => {
                const code = Number(record?.to_state ?? record?.state);
                const name = String(record?.to_state_name || record?.state_name || "").toLowerCase();
                if (code === 3 || name.includes("driv")) return "driving";
                if (code === 2 || name.includes("work")) return "working";
                return "resting";
            };

            const normalizeEvents = (items) => {
                return (Array.isArray(items) ? items : [])
                    .map((item) => {
                        const ts = Date.parse(item?.timestamp || item?.ts || item?.time || item?.date);
                        const state = stateFromRecord(item);
                        return Number.isFinite(ts) ? { ts, state } : null;
                    })
                    .filter(Boolean)
                    .sort((a, b) => a.ts - b.ts);
            };

            const formatHoursMinutes = (hoursFloat) => {
                const totalMinutes = Math.max(0, Math.round(hoursFloat * 60));
                const h = Math.floor(totalMinutes / 60);
                const m = totalMinutes % 60;
                return `${String(h).padStart(2, "0")}:${String(m).padStart(2, "0")}`;
            };

            const applyOvertime = (segments) => {
                const driveStates = new Set(["driving", "working"]);
                const result = [];

                let dayStart = null;
                let dayEnd = null;
                let dayDrivingMs = 0;

                const rolloverDay = (ts) => {
                    dayStart = new Date(ts);
                    dayStart.setHours(0, 0, 0, 0);
                    dayStart = dayStart.getTime();
                    dayEnd = dayStart + 24 * HOUR_MS;
                    dayDrivingMs = 0;
                };

                segments.forEach((seg) => {
                    if (dayStart === null || seg.start >= dayEnd) {
                        rolloverDay(seg.start);
                    }

                    let cursor = seg.start;
                    while (cursor < seg.end) {
                        if (cursor >= dayEnd) {
                            rolloverDay(cursor);
                        }
                        const sliceEnd = Math.min(seg.end, dayEnd);
                        const duration = sliceEnd - cursor;

                        if (!driveStates.has(seg.state)) {
                            result.push({ ...seg, start: cursor, end: sliceEnd, overtime: false });
                        } else {
                            const remainingBeforeOvertime = Math.max(0, DAILY_EXT_LIMIT_MS - dayDrivingMs);
                            if (remainingBeforeOvertime <= 0) {
                                result.push({ ...seg, start: cursor, end: sliceEnd, overtime: true });
                                dayDrivingMs += duration;
                            } else if (duration <= remainingBeforeOvertime) {
                                result.push({ ...seg, start: cursor, end: sliceEnd, overtime: false });
                                dayDrivingMs += duration;
                            } else {
                                const splitPoint = cursor + remainingBeforeOvertime;
                                if (remainingBeforeOvertime > 0) {
                                    result.push({ ...seg, start: cursor, end: splitPoint, overtime: false });
                                    dayDrivingMs += remainingBeforeOvertime;
                                }
                                result.push({ ...seg, start: splitPoint, end: sliceEnd, overtime: true });
                                dayDrivingMs += duration - remainingBeforeOvertime;
                            }
                        }

                        cursor = sliceEnd;
                    }
                });

                return result;
            };

            const computeWindow = (events) => {
                if (events.length >= 2) {
                    const startMs = events[0].ts;
                    const endMs = events[events.length - 1].ts;
                    if (Number.isFinite(startMs) && Number.isFinite(endMs) && endMs > startMs) {
                        return { startMs, endMs };
                    }
                }
                const referenceTs = events.length ? events[events.length - 1].ts : Date.now();
                const start = new Date(referenceTs);
                start.setHours(0, 0, 0, 0);
                const startMsFallback = start.getTime();
                const endMsFallback = startMsFallback + 24 * HOUR_MS;
                return { startMs: startMsFallback, endMs: endMsFallback };
            };

            const buildSegments = (events) => {
                const { startMs, endMs } = computeWindow(events);
                timelineStartMs = startMs;
                timelineEndMs = endMs;
                if (!events.length) {
                    return { segments: [], startMs, endMs };
                }
                const segments = [];
                let cursor = startMs;
                let currentState = "resting";

                events.forEach((evt) => {
                    if (evt.ts <= startMs) {
                        currentState = evt.state;
                        return;
                    }
                    if (evt.ts >= endMs) return;
                    const clampedEnd = Math.max(startMs, Math.min(evt.ts, endMs));
                    if (clampedEnd > cursor) {
                        segments.push({ state: currentState, start: cursor, end: clampedEnd });
                    }
                    currentState = evt.state;
                    cursor = clampedEnd;
                });

                if (cursor < endMs) {
                    segments.push({ state: currentState, start: cursor, end: endMs });
                }

                return {
                    segments: segments.filter((seg) => seg.end > seg.start),
                    startMs,
                    endMs
                };
            };

            const prepareBars = () => {
                Object.values(bars).forEach((bar) => {
                    if (!bar) return;
                    bar.innerHTML = "";
                    bar.style.display = "flex";
                    bar.style.alignItems = "stretch";
                    bar.style.gap = "0px";
                    bar.style.padding = "4px 0";
                    bar.style.backgroundColor = "transparent";
                });
            };

            const renderSegments = (segments) => {
                prepareBars();
                if (!segments.length) return;

                const timelineHours = (timelineStartMs != null && timelineEndMs != null)
                    ? Math.max(1, (timelineEndMs - timelineStartMs) / HOUR_MS)
                    : null;
                const baseWidth = timelineHours ? timelineHours * pxPerHour : null;
                let spacer = barContainer?.querySelector("[data-role='bar-width-spacer']");
                if (!spacer && barContainer) {
                    spacer = document.createElement("div");
                    spacer.dataset.role = "bar-width-spacer";
                    spacer.style.height = "0";
                    spacer.style.margin = "0";
                    spacer.style.padding = "0";
                    spacer.style.flex = "0 0 auto";
                    barContainer.appendChild(spacer);
                }

                const sequence = [
                    ["driving", bars.driving],
                    ["working", bars.working],
                    ["resting", bars.resting]
                ];

                sequence.forEach(([stateKey, bar]) => {
                    if (!bar) return;
                    if (baseWidth) {
                        bar.style.width = `${baseWidth}px`;
                    }
                    segments.forEach((segment) => {
                        const durationHours = (segment.end - segment.start) / HOUR_MS;
                        if (durationHours <= 0) return;
                        const width = durationHours * pxPerHour;
                        const chunk = document.createElement("div");
                        chunk.style.width = `${width}px`;
                        chunk.style.height = "100%";
                        const isMatch = segment.state === stateKey;
                        const isOvertime = Boolean(segment.overtime && isMatch);
                        chunk.style.background = isMatch ? (isOvertime ? palette.overtime : palette[stateKey]) : "transparent";
                        chunk.style.opacity = isMatch ? "1" : "0.08";
                        if (isMatch) {
                            chunk.dataset.segment = "1";
                            const label = `${labels[stateKey] || stateKey}${isOvertime ? " (Straordinario)" : ""}`;
                            chunk.title = `${label} - Totale ${formatHoursMinutes(durationHours)}`;
                            const show = (evt) => {
                                const rect = chunk.getBoundingClientRect();
                                const containerRect = barContainer.getBoundingClientRect();
                                const point = evt.touches?.[0];
                                const clientX = point?.clientX ?? evt.clientX ?? rect.left;
                                const clientY = point?.clientY ?? evt.clientY ?? rect.top;
                                const ratio = rect.width > 0 ? Math.min(1, Math.max(0, (clientX - rect.left) / rect.width)) : 1;
                                const hours = durationHours * ratio;
                                const timeMs = segment.start + (segment.end - segment.start) * ratio;
                                const text = `${label}: ${formatHoursMinutes(hours)} - Ora: ${formatClockTime(timeMs)}`;
                                crosshair.hide();
                                tooltip.show(text, clientX, clientY);
                            };
                            const hide = () => tooltip.hide();
                            chunk.addEventListener("mouseenter", show);
                            chunk.addEventListener("mousemove", show);
                            chunk.addEventListener("mouseleave", hide);
                            chunk.addEventListener("touchstart", (ev) => { show(ev); }, { passive: true });
                            chunk.addEventListener("touchmove", (ev) => { show(ev); }, { passive: true });
                            chunk.addEventListener("touchend", hide);
                        }
                        bar.appendChild(chunk);
                    });
                });

                if (spacer && baseWidth) {
                    spacer.style.width = `${baseWidth}px`;
                }
            };

            const fetchDriverHistory = async () => {
                const res = await fetch("/dashboard/driverdump", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        Accept: "application/json"
                    },
                    credentials: "include",
                    body: JSON.stringify({ driver: driverId, imei })
                });
                if (!res.ok) {
                    throw new Error(`driverdump failed with status ${res.status}`);
                }
                const payload = await res.json();
                return normalizeEvents(payload?.data || []);
            };

            const rerender = (preserveCursor = false, cursorClientX = null) => {
                if (!cachedSegments.length) return;
                const rect = barContainer?.getBoundingClientRect();
                let targetTime = null;
                if (preserveCursor && rect && timelineStartMs != null && timelineEndMs != null) {
                    const clientX = cursorClientX ?? (rect.left + rect.width / 2);
                    const offsetX = (clientX - rect.left) + barContainer.scrollLeft;
                    const totalMs = timelineEndMs - timelineStartMs;
                    targetTime = timelineStartMs + (offsetX / pxPerHour) * HOUR_MS;
                }
                renderSegments(cachedSegments);
                if (targetTime && timelineStartMs != null && timelineEndMs != null) {
                    const totalMs = timelineEndMs - timelineStartMs;
                    const ratio = totalMs > 0 ? Math.min(1, Math.max(0, (targetTime - timelineStartMs) / totalMs)) : 0;
                    const newOffset = ratio * ((totalMs / HOUR_MS) * pxPerHour);
                    if (barContainer) {
                        barContainer.scrollLeft = newOffset;
                    }
                }
            };

            const boot = async () => {
                try {
                    const events = await fetchDriverHistory();
                    const { segments, startMs, endMs } = buildSegments(events);
                    const enrichedSegments = applyOvertime(segments);
                    cachedEvents = events;
                    cachedSegments = enrichedSegments;
                    cachedStartMs = startMs;
                    cachedEndMs = endMs;
                    renderSegments(enrichedSegments);
                    if (barContainer) {
                        const handleMove = (evt) => {
                            const target = evt.target;
                            const isSegment = target?.dataset?.segment === "1";
                            if (isSegment) return;
                            if (!timelineStartMs || !timelineEndMs) return;
                            const rect = barContainer.getBoundingClientRect();
                            const clientX = evt.clientX ?? 0;
                            const clientY = evt.clientY ?? 0;
                            const offsetX = (clientX - rect.left) + barContainer.scrollLeft;
                            const offsetY = (clientY - rect.top);
                            const totalMs = timelineEndMs - timelineStartMs;
                            const ratio = totalMs > 0 ? Math.min(1, Math.max(0, offsetX / (totalMs / HOUR_MS * pxPerHour))) : 0;
                            const timeMs = timelineStartMs + ratio * totalMs;
                            crosshair.show(offsetX, offsetY);
                            tooltip.show(`Ora: ${formatClockTime(timeMs)}`, clientX, clientY);
                        };
                        const handleLeave = () => {
                            crosshair.hide();
                            tooltip.hide();
                        };
                        barContainer.addEventListener("mousemove", handleMove);
                        barContainer.addEventListener("mouseleave", handleLeave);
                    }
                } catch (err) {
                    console.warn("[driverChart] unable to build chart", err);
                }
            };

            window.addEventListener("load", boot);
        })();
    </script>
</body>

</html>
